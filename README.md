# データベーススペシャリストメモ

## 午後問題のビジネスモデル

### 在庫管理業務
「どこに」「何が」「いくつ」あるのかというのが「在庫」エンティティになる。
* 「どこに」: 倉庫コード
* 「何が」: 品目コード(商品コード)
* 「いくつ」: 実在庫数量

|-  | -|
|---|---|
|実在庫数量 |実際に現段階で保持している数量。<br> 「引当」時点では処理しない。「資産」に関係する。 |
|引当済み数量  |受注時になどに「確保」された数量。倉庫からはまだ取り出されていない  |
|引当可能数量  |現時点で引当可能な数量。実在庫数量 - 引当済み数量 |
|入荷予定数量  |発注済みだが、まだ入荷されていない数量 |
|基準在庫数量  |この数量を下回ったら発注する設定 |

#### 棚卸し
実際の商品の在庫数を人の目で確認し、記帳する処理。<BR>
実在庫を調べ、棚卸し資産や売上原価を求める。<BR>
コンピュータ在庫を利用しているところでは、実在庫をとの「差」を確かめることができる

* 棚卸数: 実際に目で数えたもの
* 棚卸差異数: コンピュータで管理している「在庫数」と「棚卸数」の差。
### 受注業務
受注関連の問題文でチェックするところ
1. 1つの受注で同じ商品等の指定が可能かどうか？ -> 普通は1つの受注で同じ商品を複数明細に分けないが、同じ商品を何品も指定できる場合、「受注No, 商品No」というような主キーにならない。
2. 引当の有無 -> 受注段階で引当を行っているかどうか。引当しているなら「在庫」or「生産枠」に受注番号などの属性が必要になる。

あと、受注は大体「案件」「見積」「商談」などのエンティティと紐づく。

### 出荷管理業務

#### 流れ
受注 -> 出荷指示 -> 出荷 -> 配送 -> 納品

#### 出荷や出庫処理があるときは「受注」との関係に注目
* 「分割納品」ができるかどうか -> 受注と出荷が1:多
* 複数の受注に対して、まとめて出荷ができるかどうか -> 受注と出荷が多:1

### 売上・債権管理業務
#### 基本パターン

* 出荷と売上 -> 1:1
* 出荷明細と売上明細 -> 1:1

#### 問題文から読み取るところ
* 「売上」と「売上明細」エンティティの有無 -> 出荷や納品ベースに請求しているかどうか
* 請求に必要な情報をどこに保持しているか -> 「売上」「売上明細」の属性化、「出荷」などか。


### 発注、仕入れ、支払い業務
#### 流れ

発注 -> 入荷 -> 仕入管理 -> 買掛管理 -> 支払

* 買掛管理: 仕入先に債務が発生し、支払い予定表などを作成
* 支払い: 請求先が送られてくると、支払い予定表と突き合わせチェックする。<br>
間違いがなければ振り込み一覧表を出力したり、「講座振り込みデータ」を作成し、出金処理など行う

#### 発注方式
|-  | -|
|---|---|
|分納発注方式 |予め契約している仕入先に対し、<br>生産計画に合わせて月間発注送料を事前に提示し、<br>必要となった時点で具体的な納入年月日と納入数量を<br>確定させて指示を出す。 |
|都度発注  |在庫の推移や生産見通しなどを考慮して、<br>発注ごとに仕入先や発注数量を決定し発注する。|
|定量発注  |毎日の業務終了時に在庫数量を確認し、<br>部品ごとの所定の数量を下回っている場合、一定数量を発注する。

## 関係スキーマ

### 基礎
* 関数従属性: 「項目Xの値を決定すると、項目Yの値が1つに決定される」`X -> Y`
* 候補キー: 主キーの候補となるようなキー。タプルを一意に識別できることに加え、「極小」であることが条件。「極小」とはある組を一意に決定するために余計な属性を含まないことを指す。NULLを許可する属性でもOK
* スーパーキー: 候補キー以上に存在する。タプルを1つに特定できるという条件さえ満たせばいい。「極小」でないのがスーパーキー
* 主キー: 候補キーのうち、NULLが許可されず最もふさわしいものが主キーになる。
* サロゲートキー: 主キーの代わりとなる「代理キー」。通常、一意な連番が使われる。
* 情報無損失分解: 分解後の関係を自然結合したら分解前に復元できる分解のこと。
* 第2正規形: **候補キーの一部分に非キー属性が関数従属している箇所がないとき**第2正規形を満たしている。ex) 商品名は候補キー{伝票番号, 商品ID}の商品IDに部分関数従属している。候補キーが1つのときは必然的に第2正規形を満たしている。第2正規形であるかどうかは、**候補キーが複数の項目で構成されているとき**の場合のみ。
* 第3正規形: 非キー属性が候補キーに推移的に関数従属してる箇所がないとき第3正規形を満たしている。ex) {伝票番号, 店舗ID, 店舗名 }表があり、伝票番号が候補キーのとき、**非キー属性の店舗名は、同じく非キー属性の店舗IDに関数従属しているため、推移的に関数従属していると言える**。<br>
また、第3正規形にする時点で小計、合計などの計算できる項目「導出項目」も削除する。
### 関数従属性を読み取れる表現
1. 「一意」: 「意味や値が1つに確定していること」なので関数従属性がある
2. 「同じ〇〇を登録することができない」: 「〇〇」は重複しないという意味になるので一意に値が決まる。
3. 「□□ごとに〇〇が1つに決まる」: 「□□」が決定項として「〇〇」で示される項目を被決定項とする関数従属性が成立している。


### 〇〇正規形である根拠の答え方
常套句を使う

* 第1正規形である理由: 「全ての属性が単一値で、候補キー{A, B}の一部であるBに非キー属性のCが部分関数従属するため」
* 第2正規形である理由: 「全ての属性が単一値で、候補キーからの部分関数従属ががなく、推移的関数従属性A -> B -> Cがあるため」
* 第3正規形である理由: 「全ての属性が単一値で、候補キーからの部分関数従属ががなく、候補キーからの推移的関数従属性がないため」
## 用語


## データ操作、SQL関係
* SAVEPOINT: ロールバックすれば全て戻せるけど、全部戻したくないとき「SAVEPOINT」を設定すると、その地点までロールバックできる。
* SQLのNull: WHERE句には引っかからない
* 直積結合: すべての組み合わせ。**CROSS JOIN**のこと
* 等結合演算: 直積結合の集合から、結合属性の値が等しい組を抽出したもの
* 商演算: 関係Rのうち関係Sの全ての項目を含む行
* COALSCE: SQL Serverの`ISNULL()`, Oracleの`NVL()`と同じ
* ドメイン: 「ある属性がとり得る値の集合」。データ型と同じ意味。
### トランザクション関係

* 2相ロックプロトコル: トランザクション処理で必要になったデータに都度ロックをかけていき、全てのロックを獲得した後にだけ、ロックの解除を行うルール。ロックがとれないものがあると、ロックがとれたものはそれがとれるまでロックされ続けるのでデッドロックになる可能性がある。
* 同時実行制御: トランザクションのコミットを「2つのフェーズ」に分けて行う。分散データベースで使われる。
    1. 親が子へ、コミット可能かどうかを問い合わせるメッセージを送信
    2. それぞれ子が、可否を親へ送信
    3. コミット可能であれば親がコミット指示を子へ送信。(どれか子がダメならここでロールバック)
    4. 子がコミットをして、コミット完了メッセージを親へ送信
    5. 子全ての完了を受け取ると、親はトランザクション完了させる。
* WAL(Write Ahead Log)プロトコル: トランザクションがログをディスクに書き出すタイミングについての取り決め。ログに書き込まれているのが保証されているので障害が発生してもログから矛盾のないデータを復元することができる。
    * データベースの更新は、まずそれをログを書き出してから行う(更新前ログ)
    * トランザクションはコミットを行う前に、該当する全てのデータベース更新情報をログを書き出す(更新後ログ)
* DBMSがトランザクションのコミット完了とみなすタイミング: コミットを発行されたからといって即座に更新内容が反映されるわけではない。**更新後ログが物理的記憶装置に書き込まれた**タイミングでコミット完了となる。
* 待ちグラフ: 実行中のトランザクションを各ノードにしてデータのアンロック待ちの様子を矢印で記述したもの。デッドロックが発生していることを検出する際に使用される。
* 楽観的排他制御: めったなことでは同時更新は起きないだろうという前提の排他制御。楽観的排他では、更新時に更新対象データが取得時と変わらないことを判定するためにVersionカラム使って同じVersionであることを確認してから更新する。
* 悲観的排他制御: 他者が同時更新をするであろうという前提の排他制御。更新対象データの取得時にロックをかけることで、他のトランザクションから更新されないようにする方式。
* 直列可能性: 複数のトランザクションが同時に実行される際に、トランザクションが交互にどんな順番で実行されても、1つずつ順次処理したのと変わらない結果になること
* リード現象
    * ダーティリード(dirty read): コミットされていないトランザクションでの変更を、**他のトランザクションがReadできてしまうこと**。変更したトランザクションがロールバックされると参照したほうは**存在しない値**を読んでしまったことになる。
    * ノンリピータブルリード(Non-repeatable reads): トランザクション内(A)で参照後、他トランザクション(B)が対象レコードを更新、コミット後、Aで参照すると最初に読んだ値と異なる。
    * ファントムリード(Phantom reads): トランザクションAでテーブル1を参照したあと、トランザクションBでテーブル1にINSERT or DELETEし、コミット後、トランザクションAで再度読み込むとBのコミットが反映された状態でReadできてしまう
* トランザクションのコミット時のログやバッファ: トランザクションがコミットされるとDBMSは更新情報をメモリ上の**バッファ**と**ログファイル**に書き出す。ログファイルはコミット時、即時書き出されるけどバッファは即時ではなくチェックポインの処理などでディスクに書き出される。
#### トランザクション分離レベル
○：発生する ×：発生しない

|    分離レベル     | ダーティリード | ファジーリード | ファントムリード |
|:-----------------|:-------------:|:-------------:|:--------------:|
| READ UNCOMMITTED |       ○       |       ○       |       ○        |
| READ COMMITTED   |       ×       |       ○       |       ○        |
| REPEATABLE READ  |       ×       |       ×       |       ○        |
| SERIALIZABLE     |       ×       |       ×       |       ×        |

